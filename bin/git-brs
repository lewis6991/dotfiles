#! /usr/bin/env python3
"""
This module provides utilities for displaying information about Git branches,
pull requests (PRs), and Gerrit code reviews in a formatted and colorized manner.
It integrates with GitHub CLI (`gh`) and Gerrit via SSH to fetch metadata about
branches, PRs, and code review approvals, and prints them with enhanced formatting
for terminal output, including hyperlinks and color codes.
"""

from __future__ import annotations

from dataclasses import dataclass
from functools import cached_property
import re
import shlex
import json
import argparse

import subprocess

from typing import TypedDict
from enum import StrEnum

_ARROW = '\uf553'
_THIS = '\uf111'


class _Ansi(StrEnum):
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    END = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    GREY = '\033[90m'

    # hyperlinks
    OSC8_1 = '\033]8;;'
    OSC8_2 = '\033\\'
    OSC8_3 = '\033]8;;\033\\'


def _run(cmd: str | list[str]) -> str:
    if isinstance(cmd, str):
        cmd = shlex.split(cmd)
    return subprocess.run(cmd, capture_output=True, text=True, check=True).stdout.strip()


def _link(text: str, url: str) -> str:
    return f'{_Ansi.UNDERLINE}{_Ansi.OSC8_1}{url}{_Ansi.OSC8_2}{text}{_Ansi.OSC8_3}{_Ansi.END}'


@dataclass
class _Gerrit:
    _host: str
    _port = 29418

    class User(TypedDict):
        name: str
        email: str
        username: str

    class Approval(TypedDict):
        type: str
        value: str
        by: _Gerrit.User

    class PatchSet(TypedDict):
        number: int
        revision: str
        parent: list[str]
        ref: str
        uploader: _Gerrit.User
        author: _Gerrit.User
        createdOn: int
        kind: str
        sizeInsertions: int
        sizeDeletions: int

    class CurrentPatchSet(PatchSet):
        approvals: list[_Gerrit.Approval]

    class QueryResult(TypedDict):
        url: str
        currentPatchSet: _Gerrit.CurrentPatchSet
        patchSets: list[_Gerrit.PatchSet]
        number: int
        project: str
        subject: str
        status: str

    @staticmethod
    def get_change_id(commit_body: list[str]) -> str | None:
        for line in commit_body:
            if m := re.search('Change-Id: (.*)', line):
                return m.group(1)
        return None

    @staticmethod
    def _get_approvals(obj: _Gerrit.QueryResult) -> dict[str, dict[str, str]]:
        approvals = obj['currentPatchSet'].get('approvals', [])
        approvals1: dict[str, dict[str, str]] = {}
        for approval in approvals:
            value = approval['value']
            atype = approval['type']
            name = approval['by']['name']
            approvals1.setdefault(atype, {})[name] = value
        return approvals1

    @staticmethod
    def _fmt_approval(approval: _Gerrit.Approval) -> str:
        value = approval['value']
        name = approval['by']['name']
        pos = int(value) > 0
        color = _Ansi.GREEN if pos else _Ansi.RED
        v = f'+{value}' if pos else f'{value} ({name})'
        return color + v

    @staticmethod
    def _fmt_label(label: str, approvals: list[_Gerrit.Approval]) -> str:
        label_abbr = ''.join(word[0].lower() for word in label.split('-'))
        values = ', '.join(_Gerrit._fmt_approval(a) for a in approvals)

        fail = any(int(a['value']) < 0 for a in approvals)
        if fail:
            return f'{_Ansi.RED}{label_abbr}[{values}{_Ansi.RED}]{_Ansi.END}'

        n = len(approvals)
        return f'{_Ansi.GREEN}{label_abbr}[{n}]{_Ansi.END}'

    def _info_for_result(self, result: _Gerrit.QueryResult, sha: str | None = None):
        currentps = result['currentPatchSet']['number']
        patchset = '?'
        if sha is not None:
            for ps in result['patchSets']:
                if ps['revision'] == sha:
                    patchset = ps['number']
                    break
        else:
            print(f'{_Ansi.YELLOW}{result["project"]}:{_Ansi.END}')
            print(f'      {_Ansi.BLUE}{result["subject"]}{_Ansi.END}')

        ln = _link(f'{self._host}/{result["number"]}', result['url'])

        print(f'      └ {ln} ', end='')

        if sha is not None:
            color = _Ansi.GREEN if result['currentPatchSet']['revision'] == sha else _Ansi.RED
            print(f'{color}{patchset}/{currentps}{_Ansi.END}', end='')
        else:
            print(f'{_Ansi.BLUE}ps {currentps}{_Ansi.END}', end='')

        match result['status']:
            case 'NEW':
                pass
            case x:
                print(f', {_Ansi.BLUE}{x.lower()}{_Ansi.END}', end='')

        approvals_by_label: dict[str, list[_Gerrit.Approval]] = {}
        for approval in result['currentPatchSet'].get('approvals', []):
            approvals_by_label.setdefault(approval['type'], []).append(approval)

        labels = ', '.join(
            _Gerrit._fmt_label(label, approvals) for label, approvals in approvals_by_label.items()
        )
        if labels:
            print(f', {labels}', end='')
        print()

    def _query(self, query: str) -> list[_Gerrit.QueryResult]:
        lines = _run(
            [
                'ssh',
                self._host,
                '-p',
                str(self._port),
                'gerrit',
                'query',
                query,
                '--current-patch-set',
                '--patch-sets',
                '--format=JSON',
            ]
        ).splitlines()
        return [json.loads(line) for line in lines]

    def info(self, query: str, sha: str | None = None):
        for result in self._query(query)[:-1]:
            self._info_for_result(result, sha)

    @staticmethod
    def init() -> _Gerrit | None:
        url = _run('git config --get remote.origin.url').strip()
        if match := re.match(r'(?:ssh://)?(?:[^@]+@)?([^:/]+)', url):
            host = match.group(1)
        else:
            host = url.split(':')[0]

        # Test if gerrit_host points to a Gerrit server via SSH
        if 'gerrit' not in host:
            return

        try:
            _run(f'ssh {host} -p {_Gerrit._port} gerrit version')
            return _Gerrit(host)
        except subprocess.CalledProcessError:
            pass


@dataclass
class _Github:
    _name_with_owner: str

    class PR(TypedDict):
        headRefName: str
        url: str
        isDraft: bool
        state: str
        number: int

    @cached_property
    def _prs(self) -> list[_Github.PR]:
        try:
            r = _run(
                [
                    'gh',
                    'pr',
                    'list',
                    '--json=headRefName,url,isDraft,state,number',
                    '--state=all',
                    '--limit=300',
                    '--author=@me',
                ]
            )
            return json.loads(r)
        except subprocess.CalledProcessError as e:
            print(e.stderr)
            return []

    def get_pr(self, branch: str) -> str | None:
        pr = next((pr for pr in self._prs if pr['headRefName'].startswith(branch)), None)
        if not pr:
            return None

        url = pr['url']
        state = pr['state']

        r: list[str] = []

        if pr['isDraft']:
            r.append(f'{_Ansi.BLUE}draft{_Ansi.END}')

        if state != 'OPEN':
            state_color = _Ansi.GREEN if state == 'MERGED' else _Ansi.RED
            r.append(f'{state_color}{state.lower()}')

        ln = _link(f'{self._name_with_owner}#{pr["number"]}', url)
        return f'      {ln} ' + ', '.join(r)

    @staticmethod
    def init() -> _Github | None:
        try:
            obj = json.loads(_run('gh repo view --json=nameWithOwner'))
            return _Github(obj['nameWithOwner'])
        except subprocess.CalledProcessError:
            return None


def _print_branch_info(branch: str, github: _Github | None, gerrit: _Gerrit | None):
    upstream = _run(f'git branch --list {branch} --format=%(upstream:short)')
    upstream_track = (
        _run(f'git branch --list {branch} --format=%(upstream:track)')
        .replace('ahead ', '↑')
        .replace('behind ', '↓')
        .replace(', ', '')[1:-1]
    )

    date = _run(['git', 'log', '-1', '--format=%cd', '--date=relative', branch])

    branch_info = _run(
        [
            'git',
            'branch',
            '--color=always',
            '--list',
            '--format',
            f'%(color: bold green)%(if)%(HEAD)%(then){_THIS} %(else)  %(end)'
            + f'%(color:yellow)%(refname:short)%(color:reset) {_ARROW} '
            + '%(color:blue)%(upstream:short) '
            + f'%(color:white){upstream_track} '
            + f'%(color:magenta)({date})',
            branch,
        ]
    )

    print(branch_info)
    if github and (pr := github.get_pr(branch)):
        print(pr)

    if not upstream or upstream_track == 'gone':
        return

    output = _run(['git', '--no-pager', 'log', '--format====%H%n%s%n%b', f'{upstream}..{branch}'])

    for commit in output.split('===')[1:]:
        sha, summary, *body = commit.strip().splitlines()
        print(f'    - {summary}')
        if gerrit and (changeid := _Gerrit.get_change_id(body)):
            gerrit.info(changeid, sha)


def main():
    parser = argparse.ArgumentParser(description='Display Git branches with PR and Gerrit info')
    parser.add_argument('--remote', action='store_true', help='Include remote branches')
    args = parser.parse_args()

    gerrit = _Gerrit.init()
    if args.remote:
        if gerrit:
            gerrit.info('owner:me is:open')
        return

    github = _Github.init()

    for branch in _run(['git', 'branch', '--format=%(refname:short)']).splitlines():
        _print_branch_info(branch, github, gerrit)


if __name__ == '__main__':
    main()
