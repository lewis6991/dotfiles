#! /usr/bin/env python3
"""
This module provides utilities for displaying information about Git branches,
pull requests (PRs), and Gerrit code reviews in a formatted and colorized manner.
It integrates with GitHub CLI (`gh`) and Gerrit via SSH to fetch metadata about
branches, PRs, and code review approvals, and prints them with enhanced formatting
for terminal output, including hyperlinks and color codes.
"""

import re
import shlex
import json

import subprocess

from typing import TypedDict
from enum import StrEnum

ARROW = '\uf553'
THIS = '\uf111'

GERRIT_PORT = 29418  # Gerrit SSH port


class Ansi(StrEnum):
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    WARN = '\033[93m'
    RED = '\033[91m'
    END = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    GREY = '\033[90m'

    # hyperlinks
    OSC8_1 = '\033]8;;'
    OSC8_2 = '\033\\'
    OSC8_3 = '\033]8;;\033\\'


class GerritUser(TypedDict):
    name: str
    email: str
    username: str


class GerritApproval(TypedDict):
    type: str
    value: str
    by: GerritUser


class GerritPatchSet(TypedDict):
    number: int
    revision: str
    parent: list[str]
    ref: str
    uploader: GerritUser
    author: GerritUser
    createdOn: int
    kind: str
    sizeInsertions: int
    sizeDeletions: int


class GerritCurrentPatchSet(GerritPatchSet):
    approvals: list[GerritApproval]


class GerritQueryResult(TypedDict):
    url: str
    currentPatchSet: GerritCurrentPatchSet
    patchSets: list[GerritPatchSet]
    number: int
    project: str
    status: str


def _run(cmd: str | list[str]) -> str:
    if isinstance(cmd, str):
        cmd = shlex.split(cmd)
    return subprocess.run(cmd, capture_output=True, text=True, check=True).stdout.strip()


def _get_prs() -> str:
    try:
        return _run(
            [
                'gh',
                'pr',
                'list',
                '--json',
                'headRefName,url,isDraft,state',
                '--template',
                '{{range .}}{{.headRefName}} {{.url}} {{.isDraft}} {{.state}}{{"\\n"}}{{end}}',
                '--state',
                'all',
                '--limit',
                '300',
                '--author',
                '@me',
            ]
        )
    except subprocess.CalledProcessError:
        return ''


def _get_pr(branch: str, prs: str) -> str:
    prinfo = next((line for line in prs.splitlines() if line.startswith(branch)), None)
    if not prinfo:
        return ''

    parts = prinfo.split()
    url = parts[1]
    isdraft = parts[2] == 'true'
    state = parts[3]

    draft = '[DRAFT]' if isdraft else ''
    state_color = {
        'MERGED': 'green',
        'OPEN': 'blue',
        'CLOSED': 'red',
    }.get(state, 'white')

    if branch in ['master', 'main'] and state != 'OPEN':
        return ''

    return f'\n      %(color:{state_color}){state}{draft}: %(color:cyan){url}'


def _process_branch(branch: str, prs: str, gerrit_host: str | None):
    upstream = _run(f'git branch --list {branch} --format=%(upstream:short)')
    upstream_track = (
        _run(f'git branch --list {branch} --format=%(upstream:track)')
        .replace('ahead ', '↑')
        .replace('behind ', '↓')
        .replace(', ', '')[1:-1]
    )

    prline = _get_pr(branch, prs)
    date = _run(f'git log -1 --format=%cd --date=relative {branch}')

    branch_info = _run(
        [
            'git',
            'branch',
            '--color=always',
            '--list',
            '--format',
            f'%(color: bold green)%(if)%(HEAD)%(then){THIS} %(else)  %(end)'
            + f'%(color:yellow)%(refname:short)%(color:reset) {ARROW} '
            + '%(color:blue)%(upstream:short) '
            + f'%(color:white){upstream_track} '
            + f'%(color:magenta)({date}){prline}',
            branch,
        ]
    )

    print(branch_info)

    if not upstream or upstream_track == 'gone':
        return

    output = _run(f'git --no-pager log --format====%H%n%s%n%b {upstream}..{branch}')

    for commit in output.split('===')[1:]:
        sha, summary, *body = commit.strip().splitlines()
        print(f'    - {summary}')
        if gerrit_host:
            _gerrit_info(gerrit_host, body, sha)


def _get_change_id(commit_body: list[str]) -> str | None:
    for line in commit_body:
        if m := re.search('Change-Id: (.*)', line):
            return m.group(1)
    return None


def _link(text: str, url: str) -> str:
    return f'{Ansi.UNDERLINE}{Ansi.OSC8_1}{url}{Ansi.OSC8_2}{text}{Ansi.OSC8_3}{Ansi.END}'


def _get_approvals(obj: GerritQueryResult) -> dict[str, dict[str, str]]:
    approvals = obj['currentPatchSet'].get('approvals', [])
    approvals1: dict[str, dict[str, str]] = {}
    for approval in approvals:
        value = approval['value']
        atype = approval['type']
        name = approval['by']['name']
        approvals1.setdefault(atype, {})[name] = value
    return approvals1


def _gerrit_info(host: str, commit_body: list[str], sha: str):
    changeid = _get_change_id(commit_body)
    if not changeid:
        return

    result = _run(
        f'ssh {host} -p {GERRIT_PORT} gerrit query {changeid} --current-patch-set --patch-sets --format=JSON'
    ).splitlines()

    # Query should give 2 json results
    if len(result) < 2:
        return

    obj: GerritQueryResult = json.loads(result[0])
    url = obj['url']

    currentps = obj['currentPatchSet']['number']
    patchset = '?'
    for ps in obj['patchSets']:
        if ps['revision'] == sha:
            patchset = ps['number']
            break

    def fmt_approval(name: str, value: str):
        pos = int(value) > 0
        color = Ansi.GREEN if pos else Ansi.RED
        v = f'+{value}' if pos else f'{value} ({name})'
        return f'{color}{v}'

    def fmt_label(label: str, approvals: dict[str, str]):
        abbreviated_label = ''.join(word[0] for word in label.split('-'))
        values = ', '.join(fmt_approval(name, value) for name, value in approvals.items())

        fail = False
        for _, value in approvals.items():
            if int(value) < 0:
                fail = True
                break

        if fail:
            return f'{Ansi.RED}{abbreviated_label}[{values}{Ansi.RED}]{Ansi.END}'

        n = len(approvals)
        return f'{Ansi.GREEN}{abbreviated_label}[{n}]{Ansi.END}'

    is_merged = obj['status'] == 'MERGED'
    is_merged_str = f'{Ansi.GREEN}merged{Ansi.END}' if is_merged else ''

    is_current = obj['currentPatchSet']['revision'] == sha

    change_id = obj['number']
    ln = _link(f'{host}/{change_id}', url)

    print(f'      └ {ln} ', end='')

    if is_current:
        print(f'{Ansi.GREEN}ps {patchset}/{currentps}{Ansi.END}', end='')
    else:
        print(f'{Ansi.RED}ps {patchset}/{currentps}{Ansi.END}', end='')

    if is_merged_str:
        print(f', {is_merged_str}', end='')

    labels = ', '.join(
        fmt_label(label, approvals) for label, approvals in _get_approvals(obj).items()
    )
    if labels:
        print(f', {labels})')


def _get_gerrit_host() -> str | None:
    url = _run('git config --get remote.origin.url').strip()
    if match := re.match(r'(?:ssh://)?(?:[^@]+@)?([^:/]+)', url):
        host = match.group(1)
    else:
        host = url.split(':')[0]

    # Test if gerrit_host points to a Gerrit server via SSH
    if 'gerrit' not in host:
        return

    try:
        _run(f'ssh {host} -p {GERRIT_PORT} gerrit version')
        return host
    except subprocess.CalledProcessError:
        pass


def main():
    prs = _get_prs()
    result = _run('git for-each-ref --shell --format=%(refname:short) refs/heads').splitlines()
    branches = [re.sub(r'^\'|\'$', '', entry.strip()) for entry in result]

    gerrit_host = _get_gerrit_host()
    for branch in branches:
        _process_branch(branch, prs, gerrit_host)


if __name__ == '__main__':
    main()
